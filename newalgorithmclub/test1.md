아래 템플릿은 **“처음 문제를 읽은 순간부터 코드를 제출하기 직전까지”** DP 문제를 풀 때마다 곁에 두고 체크리스트처럼 훑어볼 수 있도록 만들었습니다.
(설명은 한국어, 코드 예시는 C++17 기준)

---

## 📑 0단계 — 문제 재정의 & 필요 조건

| 질문                                                  | 체크 ✔ |
| --------------------------------------------------- | ---- |
| ❓ *최솟값·최댓값·경우 수·가능/불가능*처럼 \*\*“최적/계산”\*\*을 요구하나?    |      |
| ❓ 여러 경로·부분 결과가 **겹치는가?** (중복 부분 문제)                 |      |
| ❓ “큰 문제 = 더 작은 동일 형식 문제 + 한 결정” 구조가 보이나? (최적 부분 구조) |      |
| ✔ \*\*두 조건(중복·최적)\*\*을 모두 만족 ⇒ **DP 후보**            |      |

> DP 가 적합한지 애매하면, 우선 *DFS/BFS/그리디* 가능 여부도 1분 안에 스케치!
> (단, 시간·메모리 상한을 항상 같이 확인)

---

## 🧩 1단계 — 상태(state) 정의

1. “내가 DP 배열(또는 맵) 하나에 **저장**하고 싶은 정보가 뭔가?”
2. 그 정보를 결정짓는 **필요 최소한의 인자(차원)** 는?

   * 1D: `dp[i]` (수열 앞 i개, 금액 i, 위치 i …)
   * 2D: `dp[i][j]` (앞 i개에서 j 사용, (i,j) 격자, 두 포인터 …)
   * 그 이상: 가능하면 차원 압축(rolling array) 계획도 미리 생각

> **TIP**
>
> * “지금까지 최선/최악 결과”, “\~이 가능한가(Boolean)”, “경우의 수” 등 **형태**를 먼저 정하면 타입이 바로 결정됨 (`int/long long/bool/mod`).

---

## ⚙️ 2단계 — 전이(Recurrence) 설계

| 해야 할 일                                        | 메모                                  |
| --------------------------------------------- | ----------------------------------- |
| **①** 현재 상태에서 1번 연산(혹은 선택)을 하면 **어떤 상태**로 이동? | ex) `i → i+1`, `j → j+weight`, …    |
| **②** 그 연산의 **비용/가중치**는?                      | +1, +value, mod 연산 등                |
| **③** 후보들을 **비교/합산**해 목적에 맞게 결합               | `min`, `max`, `sum (mod)`, `OR/AND` |
| **④** 의존성 순서가 DAG 형태인지 확인                     | 싸이클 있으면 top-down + memoization      |

> 수식으로 표현해 보면 버그가 확 줄어듦
>
> $$
> dp[\text{next}] = \text{combine}(dp[\text{cur}],\;\text{cost})
> $$

---

## 🏁 3단계 — 기본값(Base Case) 및 초기화

* 상태가 **의미 없거나 도달 불가** → `+∞`, `-∞`, `false`, `0` 등 *극단 값* 넣기
* “아무 것도 안 한 상태” → 대부분 `0` 또는 `1`
  (예: `dp[0]=1` 경우의 수, `dp[0]=0` 최소 비용)

---

## 📐 4단계 — 계산 순서 & 복잡도

| 선택                    | 특징                          |
| --------------------- | --------------------------- |
| **Bottom-Up(반복)**     | 의존성 순서대로 for 문; 캐시 미스 적고 단순 |
| **Top-Down(재귀+memo)** | 코드 짧고 직관; 깊은 재귀나 큰 스택은 주의   |
| **차원 압축**             | 최근 행/열만 쓰면 `O(메모리)` ↓       |

> **Complexity = (# states) × (transition cost)**
> ⇒ 제출 전 `10^8` 연산(≈1 초 C++) 넘는지 반드시 체크.

---

## 💻 5단계 — C++ 템플릿 코드 (Bottom-Up 1D 예시)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 1e9;           // 큰 값 (최솟값 문제용)

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N;                      // 문제별 입력
    cin >> N;

    vector<int> dp(N + 1, INF); // 상태 크기만큼 초기화
    dp[1] = 0;                  // base case

    for (int x = 2; x <= N; ++x) {
        dp[x] = min(dp[x], dp[x - 1] + 1);
        if (x % 2 == 0) dp[x] = min(dp[x], dp[x / 2] + 1);
        if (x % 3 == 0) dp[x] = min(dp[x], dp[x / 3] + 1);
    }
    cout << dp[N] << '\n';
}
```

### Top-Down + Memo 패턴

```cpp
vector<int> memo;
int solve(int n) {
    if (n == 1) return 0;
    int &ret = memo[n];
    if (ret != -1) return ret;
    ret = solve(n - 1) + 1;
    if (n % 2 == 0) ret = min(ret, solve(n / 2) + 1);
    if (n % 3 == 0) ret = min(ret, solve(n / 3) + 1);
    return ret;
}
```

---

## 🔍 6단계 — 최종 체크리스트

* [ ] **경계값** 확인 (N=1, 빈 문자열, 용량=0 등)
* [ ] **자료형** 오버플로? (`long long`, `mod 1e9+7`)
* [ ] 불필요한 `O(N²)` 루프 없는가?
* [ ] 메모리(`≤256 MB` 등) 초과 여부 (`vector<int>(1e6)` ≈ 4 MB)
* [ ] **입출력 최적화** (`ios::sync_with_stdio(false)`, `\n`)
* [ ] 제출 전 작은 케이스로 수기 시뮬레이션

---

## ⚠️ 자주 까먹는 주의할 점

1. **배열 인덱스 0/1** – base case 잘못 주면 전부 무너짐.
2. **비용 누적 vs 선택 회수** – `+1` 위치 헷갈리지 않기.
3. **MOD 합 연산** – 뺄셈 시 결과 음수면 `+MOD`.
4. **복합 전이(여러 차원)** – 반복문 순서가 의존성 깨지지 않는지 체크.
5. **메모리 최적화** – 2D → 1D, 큐 두 개 rolling 등.

---

### 🏷️ 한 줄 요약

> **“상태 정의가 80 %, 나머지는 구현”**
> ⇒ *상태·전이·기본값* 세 칸에 들어갈 말을 정확히 쓰면 이미 절반은 푼 셈!
