/*

10^5 10^5까지 된다는거야.
9 3
1 2 3 4 5 / 6 7 / 8 9
이렇게 보면 15 / 13 / 17 이지. 블루레이 크기 최소값 17이야.
N과 M이 주어져. 9개 그리고 M이 머냐. M은 N보다 작아.
3개로 나눈다는 뜻이구나. 숫자가 나열되어 있지. 3개로 나누지.
정답은 블루레이크기잖아. 그 크기는 최대 45지? 안나누면 대니까.

start = 1은 아예 말이 안돼. 무조건 실패하잖아. 2 3 4 5 6 7 8 9를 못담으니까
그러니 start = 9부터 하고.
블루레이 크기가 9야 그렇다면 9와 45사이의 값으로 모든 레슨 저장가능한지 봐바.
27이겠지.
27로는 가능한 블루레이수가 M보다 작아. M=3인데 M=2가 나오지 그래서 end를 줄여.
9에서 26사이를 보자. 17이지.
17로 가능한 블루레이수가 3이야 M=3이고 같으니까 end를 줄여.
9에서 16사이는 12야. 12로 가능한 블루레이수가 M보다 많아. start 올려
13에서 16사이는 14지? 그리고 start는 mid + 1이니까.  15야.
정확한 중간찾느게 아니라 /2를 하는거니까 이런 경우가 생기는거야. 이 경우 생겼다면
불루레이수가 M보다 많아. ㄱ래서 start를 또 올려. start는 15가 되지
그럼 start = 15 end = 16이 되고, mid는 15가 돼. 15인경우도 블루레이 수가 많아. 4개야.
그러니까 mid = 15 블루레이로 레슨 나누는게 가능하다고 판단됐어. 이 경우에 더 작게 만들어도 M개의
블루레이로 나눌 수 있지 않을까?에 대한 의문을 풀어야돼. 그래서 end를 mid-1으로 줄이는거야.!!! 깨달았어. 여기가 간지러웠던 부분인거여!

start mid end
9    27   45
9    17   26 여기 17에서 M이 일치해. 그런데 M=3으로 일치해. 근데 더 작게 만들어도 나눌수있지않을까? 라는 의문 그걸 증명해야돼.
                //더 작게 만들면 나눌 수 없다. 라는걸 증명했을때 답이 17이 되는거야. 왜냐면 16으로도 나눌수 있어봐. 그럼 16이 답이잖아.
                //그래서 end를 16으로 줄여봐
9    12    16 //mid로 레슨하면 블루레이 4개되거든? 그러면 더 크기가 필요한거야. 블루레이크기 늘려
13    14    16  //14로도 블루레이 4개 돼. 크기 더 필요해. 블루레이크기늘려
15    15    16  // 블루레이 크기 총 4개야 더 필요해. 블루레이 크기 늘려
16    16    16  // 블루레이 크기 총 4개야 더 필요해. 블루레이 크기 늘려
17    16    16  // 17이 답이야 start > end가 되었거든
이진탐색은 탐색범위를 계속 좁혀가면서 답을 찾아내. start는 가능한 값중 최솟값이야
end는 가능한 값중 최댓값이야.
이진 탐색이 종료되었을 때 start가 답이 되는 이유는:

탐색 과정에서 더 작은 값들은 모두 불가능한 값으로 제외되었기 때문입니다.
start는 가능한 값 중에서 가장 작은 값이기 때문에 최종 답이 됩니다.

start가 더 중요해. start는 가능한 최솟값을 나타내고, end는 가능한 최대값을 나타내.
블루레이크기가 M=3인 경우를 만족했는데도 탐색을 멈추지 않는 이유는 더 작은 블루레이크기로 M=3을 만족할 수도 있기 때문에 end를 줄여서 탐색범위를 다시 좁힌다음 늘려나가는걸 반복해.
그리고 start값이
 */



#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int N, M;
    cin >> N >> M;
    vector<int> A(N);
    int start = 0;
    int end = 0;

    for (int i = 0; i < N; i++) {
        cin >> A[i];
        if (start < A[i]) {
            start = A[i]; // 레슨 최대값을 시작인덱스로 저장
        }
        end += A[i]; // 모든 레슨의 총 합을 종료 인덱스로 저장
    }

    while (start <= end) {
        int mid = (start + end) / 2;
        int sum = 0;//현재 블루레이에 저장된 레슨 총 길이.
        int count = 0;
        for (int i = 0; i < N; i++) { // mid값으로 모든 레슨을 저장 할 수 있는지 확인
            //현재 블루레이에 레슨을 추가하면 middle을 초과하므로 현재 블루레이를 마무리하고 count 증가시켜
            //1 2 3 4 5 6 하면 21인데 7넣으면 28이되니까 그럼 안대지. 1 2 3 4 5 6에서 멈추겠네.
            //그리고 7 8 9 하면 가능하네. 그러면 블루레이 개수 2개네.
            // 블루레이(바구니) 크기가 mid야. 반복문으로 sum했을때 mid보다 넘으면 못넣어.
            if (sum + A[i] > mid) {
                count++;
                sum = 0;
            }
            sum += A[i];
            // 1 2 3 4 5 6 7 8 9 이렇게 있어. 포인터 i가 5를 가르켜.
            //넘으면 초기화하고 다시 담아.
        }
        if (sum != 0) count++;// sum이 0이 아니야? 마지막에 이렇게 되지. 공간 남을때.
        //마지막에 똥싸다 끊는 느낌.
        if (count > M) // 카운트가 4개야 그러면 블루레이크기가 넘 작았다는거야.
            //그러면 그건 일단 실패잖아? 그 mid는 실패야. 알아낸건 mid보다는 크다라는거. 블레크기가.
            //그러면 start를 mid + 1로 둬. mid는 실패니까 무조건 mid + 1이거나 mid - 1이라는 것.

            start = mid + 1;
        else//카운트가 같거나 작아. 2개거나 3개야 그러면 블루레이크기가 넘 작았다는거야. 아니면 정답이야.
            //9~27의 중간값으로 설정하고 돌릴거야. (이건진짜) 18로 돌리겠지. 그리고 14와 27사이의 중간값
                //20을 하겟지. 그리고 20과
            end = mid - 1;
    }
    cout << start << "\n";
}

/*
for (; start <= end;) {
        int mid = (start + end) / 2;
        int sum = 0; // 현재 블루레이에 저장된 레슨 총 길이
        int count = 0;

        // 각 레슨을 mid 크기 이하의 블루레이에 저장할 수 있는지 확인
        for (int i = 0; i < N; i++) {
            if (sum + A[i] > mid) {
                count++; // 블루레이 하나가 꽉 차면 블루레이 개수 증가
                sum = 0; // 새로운 블루레이에 레슨 저장 시작
            }
            sum += A[i];
        }
        if (sum != 0) count++; // 마지막 블루레이 처리

        // 블루레이 개수가 M보다 많으면 start를 증가
        if (count > M) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }

    cout << start << "\n";
}
 */