#include <bits/stdc++.h>
using namespace std;
/*
오일러 피 소인수 분해에서 딱 2줄 넣으면 오일러피이다.
1~N에서 N과 서로소인 자연수 K의 개수
서로소 = 공통 소인수가 없는 것(1제외) = 최대공약수가 1인것 => `GCD(N,K) = 1` 인 거 찾으면 댐.
서로소가 없는 것 =  공통 소인수가 있는 것 = 최대공약수 1이 아닌것.= `GCD(N,K) = 1이 아닌것`
N의 소인수와 소인수의 배수들을 모두 제거
총 개수에서 소인수와 소인수의 배수의 개수를 차감.

result -= result/k k는 소인수
result 는 서로소인 수의 총 개수

오일러 피 코드는 소인수 분해하는 코드와 비슷해.

41-2가 더 이해하기 쉽고 직관적이야.
*/
int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    long N;
    cin >> N;
    long result = N;//일단 총 N개로 하고 거기서 뺄거야.
    // for문이 언제나 1개를 제외한 모든 소인수를 제거한다는
    for (long k = 2; k*k <= N; ++k) {
        if (N % k == 0) {//소인수라면...
            result -= result / k;//100에서 2라면 2의 배수 전부 제거해야돼. 2의 배수는 50개지?
            //2의 배수 전부 제거해도 돼. 100이 50이 되고 25가 되겠지. 이제 25 % k를 비교하면 되는거야.
            //이미 2의 배수 전부 제거 했으면 2의 소인수를 N에서 전부 제거해도 되는거야.
            while (N % k == 0) {//이제 개수는 다 줄였어. 이제 N크기도 줄여놓자. 쓴건 필요없으니까.
                //25면 5가 되겠지.
                //36 = 2 x 2 x 3 x 3이야.
                //36 2 라고하면 18 = 2 x 3 x 3이 돼.
                //18 2 라고하면 그리고 9 = 3 x 3이 되겠지
                //그리고 k=3이 되고, 9 % 3을 하겠지. 마지막에 N은 1이 되겠지.
                //35 = 7 x 5야. 그리고 7은 안나누어져서 N=7로 남겠지.
                N /= k;
            }
        }
    }
    //여기서 N은 언제나 남아있는게 7과 같은 소수이거나 1이다.
    //왜냐? 먼저 어떤 합성수 N은 최소 하나의 소인수를 sqrt(N)이하에서 갖는다.
    //둘다 sqrt(N)보다 큰 건 말이 안되기 때문이야.
    //합성수 N이 있다고 하자.
    // N = a x b라고 하자. a와 b 각각은 sqrt(N)이하의 소인수, sqrt(N) 이상의 소인수
    // N = sqrt(N) x sqrt(N)
    // N = a x b x c x ...라고 하자. a,b,c, ...각각은 sqrt(N)이하의 소인수
    //N이 sqrt(N)
    //남은 N이 합성수라면 앞서 설명한대로 최소 하나의 sqrt(N) 이하의 소인수를 가져야한다.
    //하지만 이는 이미 제거되었다.
    //100이면 2랑 5로 다 되잖아. 그런데 안되는 경우는 어떤 경우냐
    //반례를 찾아야해. N = 10 이면 2 5니까 1,3,7,,9겠네.
    //10에서 2,4,6,8,10 빼면 5를 뺴지. 그리고 5니까 1을 뺴지
    //10 - 6 = 4야.
    //14인 경우에는 14 = 2 x 7이고 1이 되겠지.
    //13인경우에는 13이 그대로 남게되네?
    // for문에서 2부터 sqrt(N)까지의 소인수들을 처리하는데 sqrt(N)보다 큰 소인수는
    //범위에 포함되지 않는다. 만약 소인수가 없는 경우는 처리하지 못한다 이거야.
    //13이면 답은 12란 말이지. 13-=13/13을 해야하는거야.
    //만약 12면 4가 제거 되겠지.
    //만약 25라면 result는 5개를 빼서 20이 되겠고.
    //N은 5가 되지. 그런데 5x5인 경우 이 경우에 소인수 5가 남았고 아직 처리 못했잖아.
    //25라면 5,10,15,20,25,

    /*
    만약에 26이 있다고 하자. 그런경우에 2x13이잖아? 그런식으로 소인수 분해가 되면
sqrt(26)은 13보다 작잖아. 그러면 처리를 못하잖아.
그런 경우에 13 26을 제거해야되잖아. 그러므로 result -= result/N을 하면
13 -= 13/13을 하겠네.
이미 처음에 2,4,6,8,10,12,14,16,18,20,22,24,26 총 13개를 제거하고
그리고 13을 제거하고 ㅇㅋ?
99
이런 예외상황이 생기는 이유는 무엇이냐면, N은 소인수분해하면 3가지 case가 있기 때문이야
case1 )sqrt보다 큰 수 x sqrt 보다 작은수
case2 )sqrt인 수 x sqrt인 수
case3 )sqrt보다 작은수 x sqrt보다 작은수 x sqrt보다 작은수 x ....
case1번으로 소인수 분해하면 내 for문이 처리를 못해
case2번이나 3번으로 소인수분해되면 내 for문이 처리할 수 있어.
그러면 처음부터 3가지 케이스로 나눠서 문제 풀면 아래 if문이 필요가 없겠네?
그런데 그렇게 하면 소인수분해하는 코드 써야되고 훨씬 복잡해진다.

26 > N=13이 되지. 그러면 result는 26에서 13이 됐지? 거기서 1만 빼야대.
2의 배수를 다 지웠지. 그런데 sqrt보다 큰 수(13)의 배수는 안지웠단 말이야
그런데 2의 배수이면서 13인 배수는 지웠단 말이야.
2의 배수가 아니면서 13인 배수만 지워야한다는거지
N은 2의 배수 지운걸 반영한거고 result도 이미 2의 배수 지운걸 반영한거야.
결국 13에서 13의 배수를 지워야하는거야. 그래서 result -= result/ N이 되는거야.
만약에 26이 아니라 13 -= 13/13
N=29야 그러면 29 - 1로 답이 28일까? 아니면
그거는 result--하면 답되는거 아니야? 왜 result -= result/ N을 할까??

171같은 경우를 봐 3x3x19같은 경우 sqrt보다 큰수 x sqrt보다 작은수 x sqrt보다 작은수야.
그런경우에 result--를 한다면
171-(171/3)=114
114-(114/3)=76
N=19 , result = 76  >>> result == 75

반대경우에는
76 - (76/19) = 72개가 되지. [19 38 57 76] 4가지에 대해서 차감해야되는거야
즉, result -= result / N 해야 하는 이유는 무엇이냐면
1개만 뺄 때가 아닐때가 있어.
171,114,이런 숫자는 지금까지 소인수
3의 배수를 제거한 후 남아 있는 서로소인 수들의 개수
1~171에서 3의 배수를 제거한거라고 보면 돼. 171-171/3하면 114야.
그러면 114 -= 114/19 = 108.
즉, 1~171에서 3의 배수를 모두 제거한거가 result야.
그 1~171에서 3의 배수를 모두 제거한 개수인 result에서 19의 배수를 모두 제거해야겠지?
그러면 171/19만큼 빼줘야겠지. 1을 빼주는게 아니라.
그래서 114 - 1 = 113은 틀린거야.
만약 3 x 19 =57이면
57 - 57/3 = 38이야.
그러면 1~57에서 3을 모두 제거한게 38이야.
38개(1~57에서 3을 모두 제거한)에서 19를 모두 제거하는건 -2를 해야겠지
그래서 result--는 틀렸어.

     */
    int result2 = 0;
    // cout << result << " " << result2 << endl;
    if (N > 1) {
        // result2 = result - 1; 는 실패.
        result-=result/N;
    }
    cout << "result :: "<< result << "\n";
    cout << "result2 ::" << result2 << "\n";
}
