/*
B는 A를 일차원으로 바꾼거자나
B를 오름차순을 정렬해.
그리고 B[k]를 구해.
B[k]는 그 배열의 k번째의 수겠지.
오름차순으로 정렬되어있다는 걸 이용하는거야. 핵심은 나에게 주어진 수가 랜덤한 수가 아니라는거
주어진 수가 규칙을 가지고 있다는거 그게 핵심 그걸 이용해야 대.
이진탐색을 할 수 있겠지.
1 2 3
2 4 6
3 6 9
각 N행이 N의 배수로 이루어져 있잖아.
1 2 3 / 2 4 6 / 3 6 9 이거를 소팅해
1 2 2 / 3 3 4 / 6 6 9 이렇게 되겠네.

내가 구하는 정답은 저 9개의 숫자중에서 랜덤한 K지?
인덱스는 1부터 시작이야. K=6이면 답은 6이야. 그걸 어떻게 찾을까
K=3이면 답이 3이야. K=4라면 답은 2야. 어떻게 찾지

4(K)라면 3(N)으로 나눈 몫이 1이지. 몫이 1이니까 몫(1) + 1 = 2니까 2의 배수고 2행이야.
4(K)라면 3으로 나눈 나머지는 1이지 나머지 1이니까 1번째 열이야. 그래서 답은 2

이렇게 구하면 참 좋겠지만 배열의 크기가 10^10이란말이야. 소팅이 불가능해.
그래서 소팅없이 하는 방법을 알아내야해.

규칙적인 수열을 이진 탐색, 투포인터로 푸는 방식에는 굳이 배열을 만들지 않아도 돼.
포인터로만 해결할 수 있어.
이진 탐색으로 가능할거같지

대충 반나눠서 얘가 정답일까? 이렇게 보는거야.
mid는 우리가 중앙값으로 둬보고, 얘를 정답이라고 가정했을 때
mid보다 작은 값의 개수를 알아낸다면 그 알아낸게 K-1이라면 그 우리가 가정했던 mid값이 B의 K번째라는거지?
그니까 원래 인덱스를 통해서 값을 구했는데
값을 통해서 인덱스를 구할 수 있는 신기한 상황이네
mid보다 작은 값의 개수는 어떻게 구하냐.
각 행마다 개수가 최대 3개잖아? 그리고 다 row_index의 배수잖아. 그걸 이용하는거임
그러면 개수가 N 이거나 mid / row_index겠지.


 */


#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    long N, K;
    cin >> N >> K;
    long start = 1, end = K;
    long ans = 0;
    // 이분 탐색 수행
    while (start <= end) {
        long mid = (start + end) / 2;
        long cnt = 0;
        // 중앙 값보다 작은 수는 몇 개인지 계산.
        for (int row_index = 1; row_index <= N; row_index++) {
            //어떻게 작은 수가 몇 개일지 계산할까?
            //행마다 계산하면 되지
            //1행에서는 3개겠고
            //2행에서도 3개겠고
            //3행에서도 3개일까...??? 일단 최대는 N개라는건 알겠어. 
            //N=3이니까 한행마다 최대 3개야
            //그런데 2개 일수도있지 그런게 어떤 경우냐. 중앙값 7이야. i = 3이야
            //그러면 3의배수니까 3 6 9잖아. 그러면 2개네.
            //이건 어떻게 계산해? 7 / 3 = 2 mid / row_index네? 그냥 몫이네?
            cnt += min(mid/row_index, N);  // 작은 수를 카운트하는 핵심로직
            
        }
        if (cnt < K) {
            start = mid + 1;
        }
        else {
            ans = mid;  // 현재 단계의 중앙 값을 정답 변수에 저장
            end = mid - 1;
        }
    }
    cout << ans << "\n";
}

/*
for (long start = 1, end = N * N; start <= end; ) {
    long mid = (start + end) / 2;
    long cnt = 0;

    // 중앙 값보다 작은 수는 몇 개인지 계산.
    for (int row_index = 1; row_index <= N; row_index++) {
        // 각 행에서 mid보다 작은 수의 개수 계산
        cnt += min(mid / row_index, N);
    }

    if (cnt < K) {
        start = mid + 1;
    } else {
        ans = mid;  // 현재 단계의 중앙 값을 정답 변수에 저장
        end = mid - 1;
    }
}

 */