#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    int M, N;
    cin >> M >> N;
    vector<int> A(N+1);//자동 0으로 초기화

    for (int num = 2; num < N+1; ++num) {
        A[num] = num;
    }

    //<=sqrt(n)와 <sqrt(n)+1은 다르다...

    for (int i = 2; i*i <= N; ++i) {
        if (A[i] == 0) continue;//지웠으면 또 지우지 말고 넘어가.
        //2면 2 4 6 8 10 12 14 16 18 20
        // j는 2 4 6 8이고 i는 2 공차 2이고 i*2부터 시작이네.
        // j는 배수들이야. A는 값과 인덱스가 같아.
        for (int j = i + i ; j <= N; j += i) {// 2 4 6 8 10
            A[j] = 0;
        }
    }
    while (M <= N) {
        if ( A[M] != 0) {
            cout << A[M] << "\n";
        }
        M++;
    }
}

/*

소수를 구하는건 어려운데 소수가 아닌걸 구하는건 쉬워. (소수가 아니다 = 합성수다니까)
소수란 1과 자기자신외에 나누어떨어지지 않는 수잖아.
소수의 반대는 합성수고 합성수란건 나누어 떨어지는 수인거야.
나누어떨어지는 수는 뭐가있어? 2의 배수 전부 3의배수 전부 ....그걸 sqrt(n)까지만 가면 돼.
왜 sqrt(n)이야?
합성수의 특징. 여러 약수의 곱으로 표현되잖아. 즉, 소인수 분해가 되잖아. 소인수는 소수이면서 약수라는 말이지.
(인수는 곱의 형태로 분해되어 나오는 수를 말함)
36 = 2 2 2 3 3 이런식으로.
그런데 약수의 특징이 뭐냐면 항상 쌍을 이룬다는거야. 그리고 쌍중에 하나는 반드시 sqrt(n)이하라는 거야
36은 (1 36) (3 12) (6 6) 이렇게 다양하게 표현이 가능한데, 하나는 반드시 sqrt(n)이하야.
소인수도 약수잖아.

즉,
합성수는 반드시 소인수 분해가 가능하고
합성수의 약수 쌍중에 하나는 반드시 sqrt(N)이하라는거야. 소인수는 소수이면서 인수인거.
36 = 3 x 3 x 2 x 2
36 = 1 x 36 = 2 x 18 = 3 x 12 = 4 x 9 = 6 x 6 = ...

합성수를 제거해나가려면 각 숫자의 배수를 지워나가면 되겠지. 2 4 6 8 10 12 이렇게 싹 다 제거하는거야.
그런데 왜 sqrt(n)이하까지만, 배수를 지우면 돼?
[소수가 아닌 sqrt(n)보다 큰 수들]은 전부 다 sqrt(n)보다 작은 수들로 소인수분해가 가능해, 즉 [sqrt(n)보다 작은수]의 배수들 밖에 없어.
즉, 36 18 12 이런거는 전부다 작은 수들로 소인수 분해가 가능해.

n을 소인수분해하면 이런 형태가 돼.
100 = 5 5 2 2야.
1. n = sqrt(n)보다 큰 수 x sqrt(n)보다 작은수 = 2 x 50
2. n = sqrt(n) x sqrt(n) = 10 x 10
3. n = sqrt(n)보다 작은 수 x sqrt(n)보다 작은수 x sqrt(n)보다 작은수 x .... = 5 x 5 x 2 x 2

sqrt(n)보다 큰 수(50,20)들을 소인수분해하면.
1. sqrt(n) = sqrt(n) x 1
이 형태만 존재할 수 있으면 sqrt(n)은 소수야. 하지만 그렇지 않지. 왜냐면 소인수분해가 가능하다고 위에서 언급했잖아.
2. sqrt(n) = sqrt(sqrt(n))보다 큰수 x sqrt(sqrt(n))보다 작은수
3. sqrt(n) = sqrt(sqrt(n)) * sqrt(sqrt(n))
4. sqrt(n) = sqrt(sqrt(n))보다 작은수 x sqrt(sqrt(n))보다 작은수 x ......
sqrt(sqrt(n))도 결국 sqrt(n)보다 작은수야.

결국 sqrt(n)보다 큰 수들은 소수가 아니라면 반드시 sqrt(n)보다 작은수의 배수로 표현이 돼.
즉, 소수가 아닌 것들은 전부 다 제거가 완료되었다는 것이지.

N이 Max잖아? sqrt(n)
M부터 N 소수 구해라. 소수구하기 > 에라토스테네스의 체 NloglogN
1. 먼저 2~N까지 배열을 만들어
2. 2부터 시작해서 2의 배수들을 모두 지워. 구간은 sqrt(n)보다 작은거 까지.
105면 10.xxx전까지만 돌려보면대.
3. 배수지워. 어케하냐면, 0으로 만들어. 0이면 넘겨.
4. 배수지울때 중요한거 2, 3, 5, 7,이건 다 소수야. 2*(2~n) 3*(2~n) 이렇게 지워야해.
2 30
*/
