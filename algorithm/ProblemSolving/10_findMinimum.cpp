

/*
12 3 N L
1 5 2 3 6 2 3 7 3 5 2 6이야. Ai야. i=1부터야


1
1 5
1 5 2
1 5 2 3
1 5 2 3 6
1 5 2 3 6 2
1 5 2 3 6 2 3
1 5 2 3 6 2 3 7
이렇게 배열에 넣어서 윈도우 크기가 주어져
크기가 3이야. 처음에는 1
그다음에 1 5중에서 1
다음에 1 5 2 중에서 1
그다음에 5 2 3중에서 2
그다음에 2 3 6중에서 2
이렇게 되는거야
그런데 L그기가 윈도우 크기가 너무 커 그래서 최솟값 구하려면 O(N)비교해야대자나 그방법은
안대. 그걸 해결하는게 이 문제의 핵심인데말이지.
어떻게 해결하냐. 1 5 2 윈도우가 이동한다는거 add remove한다는거에 집중해봐
왼쪽이 remove되고 오른쪽이 add 되지?
그게슬라이딩윈도우잖아.
시간복잡도 줄이는 방법은 자료구조를 바꾸는 거겠지 머.
그리고 테스트케이스를 잘 분석해보면 최솟값이 1 1 1 2 2 2 2 2 2 3 3 2 2 가 되네.
되게 최솟값이 유지되네
원소하나하나의 의미를 생각해보면, 다르게 의미를 시각을 바꿔보면
굳이 저 배열을 다 가지고 있을 필요가 없다는 생각이 들지?
그러면 줄이자 어떻게 줄여? 필요한 정보만 가지면 돼.
1 5 2에선 필요한 정보가 3개네
1넣었어
1 5넣었어.
5가 필요할까? 만약에 6 7 나오면? 1 5 6 7 그러면 5가 필요하겠네 넌 지우면 안대
1 5 2 넣었어. 2는 필요할까? 필요하지 다음에 3 4나오면 어떡해. 그런데 여기서 5는
필요할까? 필요 없겠지. 이미 2가 왔잖아. 그럼 필요없는거야.
1 5 2 3 했어. 그러면 3은 필요하지? 2도 필요해. 5는 필요없지
그럼이렇게 하자
1 >> 1
1 5 >> 1
1 / 2 >> 1
/ / 2 3 >> 2
/ / 2 3 6 여기서 3은 필요해? 다음에 2가 지워지잖아 필요하지
/ / / 3 6 2 여기서 3은 필요해? 버려도 대. 6은 필요해? 버려도 대!
그렇다는건 지금 넣는게 6이였지 그런데 2랑 3은 필요없지.
지금 넣는게 왼쪽에 들어가잇는것보다 크면 버려도 되는거야.
/ / / / / 2 이렇게 시작하면 대.
자 지금 봐바. 1 5 2였어. 그러면 5가 필요하지 않았네
그러면 2 3 6이였어. 그때 3은 필요했네. 뒤에 뭐가 나올지 모르잖아.
뒤에 4가 나올 수도 있잖아. 그치. 그러니까 3은 필요해
3 6 2야. 그러면 6이 필요없네 3도 필요없네 주로 왼쪽에 꺼를 지울 수 있네.
오른쪽놈이 왼쪽놈보다 작으면 왼쪽놈은 필요가 없네!
왼쪽을 지우자. 오른쪽에 추가하자. 그러면 덱을 써야겠네
그러면 보면 어떻게 대. 제일 왼쪽 꺼 TOP 보다 큰 놈은 버려도 대네.
그리고 데이터만 남기면 어떻게 슬라이딩윈도우를 잘라내?
못잘라내지 그러면 인덱스정보를 남겨야대네 아니면 인덱스를 덱에 넣고
인덱스에 따라 값을 꺼내는 방법도 괜찮아. 하지만 메모리 공간을 더 쓰기는 하겠지.
 */

#include <iostream>
#include <vector>
#include <algorithm>
#include <deque>
using namespace std;
typedef pair<int, int> Node;//first를 index로. second를 value로
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int N, L;
    cin >> N >> L;
    deque<Node> Deque;

    //second가 값이야. first는 index야.

    for (int idx = 0; idx < N; idx++) {
        int input;
        cin >> input;
        // 새로운 값이 들어 올 때마다 정렬하지 않고 현재 수보다 큰 값을 덱에서 제거함으로써 시간복잡도를 줄일 수 있음
        // 제일 왼쪽을 가장 큰 작은값으로 유지해.

        //12 3
        //1 5 2 3 6 2 3 7 3 5 2 6을 넣는다고 하자.
        while (!Deque.empty() && Deque.back().second > input) {
            //지금 제일 오른쪽에 들어가 있는게(6이지 빠지면 3이됨) 앞으로 넣을 것(2)보다 크면 버려도 대
            //이거를 Deque.front()로하면 무슨 문제가 생기냐
            //처음에 1 5 들어갔지 1 5 2 되잖아. 1이 안지워지니 5도 안지워지는 문제가 생겨
            //그런데 만약 6 5지? 그러면 6이 즉시 지워지겠지. 그러니 문제가 안생겨.
            // 2. 팝하는 기준은 뒤꺼보다 작은게 들어오면 뒤쪽 팝해.
            // 기존게 더 크면 뒤쪽 팝해.
            // 새로들어온게 크면 뒤쪽 팝하지 마.
            /*
            (1,0)
            (1,0) (5,1)(이건 괜찮아)
            (1,0) (2,2)(이렇게 될거야 5를 버린거야 최솟값 구하는데 쓸모 없는 정보잖아)
             */

            Deque.pop_back();
        }
        Deque.push_back(Node(idx, input));// 1. 일단 무조건 푸시 해야겟지. 그래야 윈도우 크기가 추적이 돼.
        // 범위에서 벗어난 값은 덱에서 제거

        //만약에 이렇게 들어갔다고 하자 1 2 5 3순서대로
        //1
        //1 2
        //1 2 5 (여기서 5는 필요한가? 윈도우 크기때문에 필요하지) i는 5의 인덱스야. 지금 들어온 인덱스(2) - 윈도우크기(3)
        //(1,0) 2 (3,3) (여기서 5는 버렸어) (지금 들어온 인덱스 3 - 윈도우크기 3)
        //3-0 크기가 4야  i - front.first + 1 은 현재 윈도우 크기야. 제한은 L 그러니 i - front.first + 1 > L이면 pop.front
        //(2,1) (3,3)만 남겠지 그럼.
        //윈도우 크기는 현재 idx - 데큐제일왼쪽꺼
        if (L < idx - Deque.front().first + 1) {
            Deque.pop_front();
        }

        //이런식으로 정보를 업데이트 해. 이 경우에 왼쪽이 제일 최소값인게 유지가 되는걸 알 수 있지.
        cout << Deque.front().second << ' ';
    }
}
//
//
// #include <iostream>
// #include <vector>
// #include <deque>
// using namespace std;
//
// int main()
// {
//     ios::sync_with_stdio(false);
//     cin.tie(NULL);
//     cout.tie(NULL);
//
//     int N, L;
//     cin >> N >> L;
//     vector<int> arr(N);  // 값을 배열에 저장
//     deque<int> mydeque;  // 인덱스만 저장하는 덱
//
//     for (int i = 0; i < N; i++) {
//         cin >> arr[i];  // 배열에 값을 입력
//
//         // 현재 값(arr[i])보다 큰 값을 덱에서 제거
//         while (!mydeque.empty() && arr[mydeque.back()] > arr[i]) {
//             mydeque.pop_back();
//         }
//
//         mydeque.push_back(i);  // 현재 인덱스를 덱에 추가
//
//         // 윈도우 범위에서 벗어난 인덱스는 제거
//         if (L < i - mydeque.front() + 1) {
//             mydeque.pop_front();
//         }
//
//         // 현재 윈도우에서 최소값을 출력
//         cout << arr[mydeque.front()] << ' ';
//     }
//
//     return 0;
// }
