/*
좋은 수라는 건 배열 A에서 어떤 수가 다른 두 수의 합으로 나타나진다라는거야
10
1 2 3 4 5 6 7 8 9 10 이면
A: 1 2 3 4 5 6 7 8 9 10이고,
배열A에서 3 4 5 6 7 8 9 10은 좋다야.

만약에
3
3 5 8
이라면 8만 좋은 수겠지.

그건 어떤 수 좋은수 = A[K]가 다른 두 수의 합으로 나타나진다면 count++;

k다 다른 두 수의 합으로 나타내는지 확인하는건
투포인터 문제잖아. 양끝 start end가 합쳐서 K라면
 */

#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int N;
    cin >> N;//10개야. 그러면 초기화도 N이겠네
    /*
    좋은 수라는 건 배열 A에서 어떤 수가 다른 두 수의 합으로 나타나진다라는거야
    그럼 무조건 1빼고 싹 다 답 아니냐고? 그 얘기가 아니야. 배열 A에서 짝짝꿍한다는 얘기야.
10
1 2 3 4 5 6 7 8 9 10 이면
A: 1 2 3 4 5 6 7 8 9 10이고,
배열A에서 3 4 5 6 7 8 9 10은 좋다야.
     */
    vector<int> A(N,0);
    for (int i = 0; i < N; i++) {
        cin >> A[i];
    }
    sort(A.begin(), A.end());
    int count = 0;

    for (int k = 0; k < N; k++) {// A[0]부터 A[N-1]까지 좋은수인지 판별할거야??  A의 원소 전부 반복하겠다는 의지야.
        /*
         *그리고 모든 원소마다 반복해.
         *각 원소마다 어떻게 작동하냐면,
         *투포인터로 N배열을 탐색해서 각 원소가 좋은수임을 증명하는 케이스가 있는지 확인하는거지?
         *
         */
        int start = 0;
        int end = N - 1;
        while (start < end) {
            if (A[start] + A[end] == A[k]) {//오 두수의 합으로 나타나져!!
                if (start != k && end != k){ // 1 + 0 = 1은 안돼 다른 두 수의 합으로 나타내져야 한다고 그랬어.
                //좋은 수는 서로 다른 두 수의 합=A[K]로 나타나야 하잖아?
                //그러니까 K는 포함시키면 안대. 예를들어 3 4 0 이 주어져. 3이 좋은수야? 3+0=3이니좋은수다.라고말할수없는거야.
                count++;//좋은수라는게 판별났어? 그럼 넘어가
                    //1 좋은수야? 2좋은수야? .... 10좋은수야? 최대 count는 10이야.
                break;
                } else if (start == k) { //A[end] == 0인 경우 이럴 수 있다. 이 경우는 두 수의 합으로 나타낸거지만 "서로 다른"이 아니다. 하나가 같다.
                    start++;
                } else if (end == k) {
                    end--;
                }//start == end == k 인 경우는 없어 while문이 보장해 그걸.

            } else if (A[start] + A[end] < A[k]) {
                start++;//구해보니까 정답보다 작네? 키워야겠다
            } else {
                end--;//정답보다 크네? 줄여야겠다.
            }
        }
        //루프를 벗어나면 start == end가 돼.
    }
    cout << count << "\n";
    
}
