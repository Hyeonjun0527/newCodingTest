// Authored by : chjh2129
/*
 *스택에 높이가 들어있다는건 뭘 의미해? 새로운 높이라는 것
새로운 높이 개수 = 정답
새로운 높이를 푸시할떄마다 ans가 올라가.


새로운 높이(y[i])는 현재 스카이라인의 첫 번째 건물로 간주됩니다.
따라서, 스택이 비었을 때는 높이를 무조건 추가해야 합니다.
왜냐하면 스카이라인이 아직 형성되지 않았으므로 그 높이가 스카이라인의 시작점

스택이 비었을 때 높이가 이미 확인했던 높이일 수 있다는 문제는?
스택이 비었을 때 높이를 무조건 추가하는 이유는, 그 높이가 현재 스카이라인의 시작점이기 때문입니다. 이 문제에서 이전에 확인했던 높이와는 상관없이 스택이 비었을 때는 항상 새로운 높이로 시작해야 합니다.

스카이라인의 변화는 이전과 무관하게 스카이라인의 시작점에서부터 새로 추적해야 하기 때문에, 스택이 비었을 때는 높이를 추가하는 것이 맞습니다.
 */
#include <bits/stdc++.h>
using namespace std;

int n;
int y[1'000'005];

int main(){
    cin.tie(nullptr)->sync_with_stdio(false);

    // input
    cin >> n;
    int tmp; // x값은 버리고 높이 y값만 입력받는다.
    for(int i = 0; i < n; i++) cin >> tmp >> y[i];

    // solve;
    int ans{};
    stack<int> stk;
    for(int i = 0; i < n; i++){
        //현재 스택의 맨 위에 있는 값(가장 최근의 높이)을 의미합니다.
        while(!stk.empty() && stk.top() > y[i]) stk.pop();
        //stk.pop(): 스택의 맨 위에 있는 값(이전 높이)이 현재 처리 중인 건물 높이보다 크면, 스택에서 제거합니다.
        //이는 이전 높이가 현재 높이보다 높다면 더 이상 의미가 없기 때문입니다.
        //꼭대기였어 이전이 그런데 새로 탐색부분의 높이가 낮아졌어 그래도 개수를 세야 해.
        //높이가 변하기만 하면 스카이라인 개수 세야해.
        /*
         *만약 건물높이 차례대로 4 6 4야. 그러면
         * 스택 : 4
         * 이때는 개수를 세야지. +1이야. 그리고 6이 왔어.
         * 스택 : 4 6
         * 개수 세야지
         * 새로운 건물 높이가 4야. 그러면 6을 팝해. 새로 스카이라인 변화했으니 새로운 건물 일수도 있기 때문이야.
         * 스택 : 4
         * 그리고 새로운 높이 4를 보니 기존보다 크지 않으니까 스택은 그대로 4야.
         * 만약 새로운 높이가 3이였다면 4도 팝을 하겠지.
         * 즉, 낮은 높이 나오면 기존거를 팝 해. 이미 개수 셋으니까 지워버리는거야.
         * 스택 : 4
         */
        if(y[i] && (stk.empty() || stk.top() < y[i])){
            //y[i]==0이면 무조건 스킵. 건물이 없으니 높이를 스택에 넣지마.
            //스택이 비었으면 높이를 스택에 무조건 추가해.
            //기존높이보다 더 큰 높이가 들어오면 스택에 추가해.
            //새로운 높이가 필요할 때 스택에 추가합니다.
            stk.push(y[i]);
            ans++;
        }
    }

    // output
    cout << ans;
}